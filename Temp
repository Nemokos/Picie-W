/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/f2bb2f6f-1a43-4805-95a2-8daf7873a288 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float zTemp1;
  int b;
  int g;
  int r;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

// constants won't change. Used here to set a pin number:
const int ledPin = 7;  // the number of the LED pin

// Variables will change:
int ledState = LOW;  // ledState used to set the LED

unsigned long previousMillis = 0;  // will store last time LED was updated

const long interval = 60000;
//
#define THERMISTORPIN0 A4
// which analog pin to connect
#define THERMISTORPIN1 A5
// which analog pin to connect
#define THERMISTORPIN2 A6
// resistance at 25 degrees C
#define THERMISTORNOMINAL 100000
// temp. for nominal resistance (almost always 25 C)
#define TEMPERATURENOMINAL 25
// how many samples to take and average, more takes longer
// but is more 'smooth'
#define NUMSAMPLES 5
// The beta coefficient of the thermistor (usually 3000-4000)
#define BCOEFFICIENT 3950
// the value of the 'other' resistor
#define SERIESRESISTOR 10000

int samples[NUMSAMPLES];

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  pinMode(ledPin, OUTPUT);
  analogReference(AR_EXTERNAL);
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillis >= interval) {
    // save the last time you blinked the LED
    previousMillis = currentMillis;

    digitalWrite(ledPin, HIGH);
    uint8_t i;
    float average;

    // take N samples in a row, with a slight delay
    for (i = 0; i < NUMSAMPLES; i++) {
      samples[i] = analogRead(THERMISTORPIN0);
      delay(10);
    }

    // average all the samples out
    average = 0;
    for (i = 0; i < NUMSAMPLES; i++) {
      average += samples[i];
    }
    average /= NUMSAMPLES;

    // convert the value to resistance
    average = 1023 / average - 1;
    average = SERIESRESISTOR / average;

    float steinhart;
    steinhart = average / THERMISTORNOMINAL;     // (R/Ro)
    steinhart = log(steinhart);                  // ln(R/Ro)
    steinhart /= BCOEFFICIENT;                   // 1/B * ln(R/Ro)
    steinhart += 1.0 / (TEMPERATURENOMINAL + 273.15); // + (1/To)
    steinhart = 1.0 / steinhart;                 // Invert
    steinhart -= 273.15;                         // convert absolute temp to C

    Serial.println( currentMillis / 60000);
    Serial.print("Temperature A0 ");
    Serial.print(steinhart);
    Serial.println(" *C ");
    zTemp = steinhart;


    // take N samples in a row, with a slight delay
    for (i = 0; i < NUMSAMPLES; i++) {
      samples[i] = analogRead(THERMISTORPIN1);
      delay(10);
    }

    // average all the samples out
    average = 0;
    for (i = 0; i < NUMSAMPLES; i++) {
      average += samples[i];
    }
    average /= NUMSAMPLES;

    // convert the value to resistance
    average = 1023 / average - 1;
    average = SERIESRESISTOR / average;


    steinhart = average / THERMISTORNOMINAL;     // (R/Ro)
    steinhart = log(steinhart);                  // ln(R/Ro)
    steinhart /= BCOEFFICIENT;                   // 1/B * ln(R/Ro)
    steinhart += 1.0 / (TEMPERATURENOMINAL + 273.15); // + (1/To)
    steinhart = 1.0 / steinhart;                 // Invert
    steinhart -= 273.15;                         // convert absolute temp to C

    Serial.print("Temperature A1 ");
    Serial.print(steinhart);
    Serial.println(" *C");
    zTemp += steinhart;


    // take N samples in a row, with a slight delay
    for (i = 0; i < NUMSAMPLES; i++) {
      samples[i] = analogRead(THERMISTORPIN2);
      delay(10);
    }

    // average all the samples out
    average = 0;
    for (i = 0; i < NUMSAMPLES; i++) {
      average += samples[i];
    }
    average /= NUMSAMPLES;

    // convert the value to resistance
    average = 1023 / average - 1;
    average = SERIESRESISTOR / average;


    steinhart = average / THERMISTORNOMINAL;     // (R/Ro)
    steinhart = log(steinhart);                  // ln(R/Ro)
    steinhart /= BCOEFFICIENT;                   // 1/B * ln(R/Ro)
    steinhart += 1.0 / (TEMPERATURENOMINAL + 273.15); // + (1/To)
    steinhart = 1.0 / steinhart;                 // Invert
    steinhart -= 273.15;                         // convert absolute temp to C

    Serial.print("Temperature A2 ");
    Serial.print(steinhart);
    Serial.println(" *C");
    zTemp += steinhart;
    Serial.println(zTemp/3);
    digitalWrite(ledPin, LOW);
  }
123 test
  
}











/*
  Since R is READ_WRITE variable, onRChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRChange()  {
  // Add your code here to act upon R change
}

/*
  Since G is READ_WRITE variable, onGChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGChange()  {
  // Add your code here to act upon G change
}

/*
  Since B is READ_WRITE variable, onBChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBChange()  {
  // Add your code here to act upon B change
}
